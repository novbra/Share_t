# 实习

# 选择校招/实习Offer的逻辑

实习太简单了 学历可以的 实习描述应该是先介绍业务 再介绍技术 技术咋推动业务的 做到了啥收益 有没有做实验 实验组和对照组有什么不同 你最后学到了什么  有没有参与处理过线上问题 有没有参与过公司的code review 有没有参与过技术分享 这些都是可以在实习描述中写的 并且实习和项目不一样不会撞车 这个实习经历描述有点太偏项目了 ... 展开    

作者：程序员花海
链接：https://www.nowcoder.com/feed/main/detail/7c7a622440a645609cf04008dcdc10b7?sourceSSR=search
来源：牛客网



实习选offer永远是大厂title>业务>薪资



最近在牛客看了太多咨询Offer的同学了，给一个普适的结论：

1.选业务，脱离业务讨论公司没有任何意义，有鹅选鹅只是个梗。



2.综合对比薪资、地域、业务、组内氛围，主要还是看组 不同组之间差距很大 另外考虑好自己想做什么业务，大家选offer的时候最好提前打听下组内的氛围。



3.技术方面大家差距没有那么大，技术够用就行，能让你和别人拉开差距的主要还是对于业务的理解程度。



4.很多同学被高薪吸引过去，从来没有问过组内是做什么的，结果去了之后landing非常痛苦，所以大家最好多做准备，考虑清楚再去 。    



5.另外问下，对于校招生的培养体系和打听一下往届同学的离职率，他们的情况基本上就是这家公司近几年的写照 。



6.18 19年是随随便便面试就能拿Offer的年代，甚至是很多公司会拿出1个月，专门教你怎么写代码。但现在很多大厂对你的期望是来了之后尽快上手，所以自身能力和业务理解都要提上来，这些道理是市面上八股文里面绝对不会讲的

作者：程序员花海_
链接：https://www.nowcoder.com/discuss/829663783604772864?sourceSSR=users
来源：牛客网





实习和校招简历正确格式应该是

你的github若没东西，不要写上去

长得丑的话就别放照片

一、教育背景

二、实习经历

三、项目经历

四、技能清单

五、个人评价



 其中项目经历注意要体现业务 实习经历里面的业务更是要自圆其说 简历模板尽可能保持干净整洁 不要太花哨的

Spring Boot，MyBatis 格式问题

个人总结突出团队合作和编码能力

项目需要有数据支撑

简历里别堆技术名词，用 STAR 法则写项目

分层架构思想没有体现出来了，前端没有前端优化前端工程化体现，后端微服务以及分层架构没体现以及数据安全也没体现，核心再改改，注重于计算机网络，工程化，底层原理吧



缺少tps qps rt tp999



单独抽一个业务背景

技能放到实习下

开发要用的中间件



自我评价突出对技术的追求 吃苦耐劳 团队合作



## 马士兵学习路线小链接

```text
MCA-Java后端课程大纲（P6-P9）：https://www.processon.com/view/link/67e519afd4d0a70196afdc87
左程云老师-算法与数据结构大纲：https://shimo.im/docs/XD9YH3XYgpHQWWW6/
大数据大纲：https://www.processon.com/view/link/6244466b5653bb072bcd241d
大模型大纲：https://www.processon.com/embed/677a12b19a70b82af8823550?cid=677a12b19a70b82af8823553
java基础：https://www.processon.com/view/link/6393184ef346fb465a7f1c17
```



# 能装就装

[#找工作能把i人逼成什么样#]()第一次面试某大厂，HR问我："有分布式经验吗？" 我tm连Redis都没摸过，但想起学长教的"面试三板斧"，张口就来："虽然没实战过，但我研究过CAP理论，还自己搭过三台虚拟机模拟集群！" ——其实就是在宿舍用VirtualBox开了三个Ubuntu，ping通就截图发朋友圈装逼。



精通（敢往死里问的）、熟悉（能干活）、了解（知道是啥） 



问题太大了，首先把教育背景放前面。不然简历不用看就看被pass了。然后两个项目写了和没写一样，不如商城+点评的描述。那专业技能，前面来个技术名，后面一点都不见具体那些了。你说你熟练java，说说java反射实现方式，那些地方用，io都有那些。这让面试官怎么问。这份简历看下来，没一点问的希望。看着技术栈用的多，亮点也没解决什么实际问题。很差的一份简历，患上技术堆砌的毛病了 ... 展开    

其实我比你小，学历没你好。我的话，你捡有用的看就行了。首先，专业技能白写。投java，写那么多语言干嘛，而且你比这份简历还过分，技术就一行，说个技术的名字。怎么，这么自信，说说springboot底层怎么实现的。只需要写和java有关的，然后一个技术，要列出几点你熟悉的原理。比如熟悉rerdis，了解缓存穿透、、雪崩、击穿的解决方案。这样面试官才知道怎么问，你写了，那就说一下，你怎么实现缓存穿透的，你项目里面怎么使用的。然后就是项目。还是和这份简历一样，写了和白写没区别。不要说用什么什么实现了什么功能，没法问啊。那我还说，我用引入llm搭建了智能助手。你看这么写，你觉得你能问出什么？难道还要面试官来一点一点问你怎么实现的吗？背景+痛点+解决方案+量化结果。针对用户反馈不能及时的情况，引入了llm搭建智能客服，通过ai汇集+人工攻艰，实现剩余问题量每日零剩余。这么写，是不是面试官就可能问你ai汇集和人工攻艰这套模式具体是怎么实现的呢？是不是就自然的深入项目了。然后那个实习，不是java的就算了，因为方向不一样，实在因为公司好，那就写简单点吧，那些文档什么的，不是技术的就别要了。



## 不同方向卷的方向

#Java 后端

卷体量多少个用户同时请求，顶层设计 底层优化 性能 安全

懂业务 懂团队 懂架构









算法岗难度
CV>搜广推 
数据挖掘和智能体开发

c++通用路线(后端技术栈)，什么岗位都能投
无需过早陷入QT、游戏引擎等
四大件
算法题

![image-20251212193616668](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251212193616668.png)

- 开发

  - **AI应用**

  - **基础架构**

  - **大前端** 最卷
    
    - Web、小程序
    - App、鸿蒙(未必能迟到红利，可作为加分项来冲)
    - Client, 图形渲染
    - VR/AR, 三维交互
    
    就业：岗位较后端少
    
  - **后端**

    定义：业务处理和数据管理, AI可替代技术，但AI替代不了业务

    就业：岗位最多

    前景：架构、技术专家方向。

    核心内容：

    - **数据结构与算法**、**设计思想(架构本身)**、**底层知识(前几年涨薪点)**、**架构理念/设计(大并发量来了怎么处理，缓存来了怎么处理，一级缓存不够，多级缓存怎么办)**、**源码阅读**
    - **项目经验（调优 并发）**
    - Credits(加分项): 
      - **AI应用（私有大模型调优部署运营，在它上面做的开发应用）**
      - **大数据（大并发量和其带来的大数据量应该如何处理）**
      - **大并发量和其带来的大数据量应该如何处理（不掌握云原生，你就做不出来优秀的架构设计）**

    了解Java这些架构,C#设计的那些架构方式和模型以及它的组件其实就了解它的原理了，剩下的就是语法的不一样了

    规划：

    ```text
    text对于二本，3年一家公司（独角兽 二线大厂 中厂规模大 如链家，携程,58 特定行业里面闻名的），3年后开始大赚进大厂
    
    3年代表你的稳定性
    大厂 52 03 原则  52是五年两跳，03是某一家能工作到3年
    ```

    语言选择

    - Java 应届高薪仍在，岗位多，语言本身不是核心

      能做事儿，CRUD、初步的分布式微服务，很多外包就能接受了

    - GoLang

      没干掉Java, 但干掉了PHP了

      大厂、区块链(小公司)

    - C++

    ```text
    Client Server开发 非 BS开发
    大多用于Linux的网络的程序的开发，还有一部分是游戏的服务器的开发
    作为后端岗位相对少
    细分方向多。不过C++后端那套技术栈最通用，可根据自己喜欢的方向再去补充相关的内容
    ```

    1. 游戏   top: 40w+游戏销量发放奖金
    2. 音视频
    3. 嵌入式
    4. 其他高性能领域

    - C# 国外

      推出Donkey Core之后跨平台，在很多点上甚至是超越了Java，在中国极难推翻整个Java体系，由于其流行时间长

    - Python 国外

  - **嵌入式**

  - Java

  - C++

  - c#

  - Python
    - Agent开发
    - 大模型

- 体系结构及其他研发方向(一般从211硕士起步，顶尖企业甚至“双9”)

  优化计算机底层技术，如编译器、操作系统等

- 算法（AI）

  人工智能各个细分领域

  大模型的调用和调优不算搞算法，发明新的算法、模型

- 数据 （可作为后端的credit）

  数据分析，数据挖掘

- 测试开发

- 运维开发

- 安全

  需达到顶级黑客水平

- DBA 数据库管理员

  稳定但薪水不高人少，一个企业DBA就一两个

- 运维 岗位最少

- 测试

- 售后、实施、技术支持

- 数据标注

  标注图片



## Java路线

- 语法
- 集成开发工具的使用
- 面向对象
- JavaSE进阶
- 数据库+JDBC
- 前端精讲
- JavaEE
- 工具的使用
- Linux
- SSM框架的使用
- SpringBoot的使用
- 分布式阶段
  - RPC
  - Dubbo
  - FastDFS,Nginx
  - Redis
- 微服务阶段
  - SpringCloud
  - 微服务会话管理
  - 微服务调用OpenFeign
  - 微服务GetWay
  - 项目网约车
- 设计模式
- 多线程与高并发
- JVM
- 算法 左程云

## 后端面试速成

- Java基础

  - 面向对象OOP：
    - 封装：
    - 继承：
    - 多态：
    - 重写与重载的区别，及其应用场景
  - 字符串处理：
    - String、StringBuilder等的使用与底层实现
    - 字符串常量池的内存机制

  - **集合框架**
    - HashMap底层结构、扩容机制及线程安全问题
    - List（如ArrayList、LinkedList）的适用场景与差异

- JVM  

  考察相对固定且集中

  **内存管理**是虚拟机中的一个重要命题，JVM接手了内存管理的事宜后，相较于适用cpp开发时的手动控制，降低了开发者的门槛，也提高了程序的可维护性

  - 内存分区/运行时数据区：内存区域 堆、栈、方法区等运行时内存区域的划分与职能 ≠ 内存模型
    
    ![image-20251220201015005](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251220201015005.png)
    
    蓝色块都是可共享的，绿色块是不可共享，每个线程都有一个自己的区域。上图中的绿色块只是画出了一个，事实上有几个线程就包含多少组同样的这三个绿色块。
    
    - **方法区** 多个线程共享
    
    - **堆** 多个线程共享
    
    - Java方法栈（虚拟机栈） 每个线程都会有自己的区域，这块不共享
    
    - 本地方法栈 每个线程都会有自己的区域，这块不共享
    
    - 程序计数器 每个线程都会有自己的区域，这块不共享
    
      ![image-20251220205021009](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251220205021009.png)
    
    ![8d200cb7fba4ee6eb508f779cf319065](E:\WeChatDoc\xwechat_files\wxid_ggubr1ock2do21_2d85\temp\RWTemp\2025-12\8d200cb7fba4ee6eb508f779cf319065.jpg)
    
    需要判断当前读写的数据是共享区还是独占区，如果是共享区需要考虑是否存在线程安全问题，就是多线程并发访问修改问题。如我们new出来的对象都在堆中，需要考虑线程安全性，而线程方法中的局部变量是在虚拟机栈中
    
  - 垃圾回收（GC）
    - 常见的垃圾回收算法与机制，能说出不同垃圾收集器的基本特点
    
  - 类加载过程
    - 了解类从文件加载到JVM内存的完整生命周期
    
      类加载子系统的作用是什么？如何工作的？
    
      ![image-20251219161432068](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251219161432068.png)
    
      准备阶段为static变量分配内存并赋0值，在初始化阶段才赋实值，解析是指将类名解析为对应的内存地址。举个例子：编译阶段，代码中调用`Object.toString()`，编译器无法知道`toString()`在运行时的内存地址，只能在常量池中记录`java/lang/Object.toString:()Ljava/lang/String;`（符号引用）；解析阶段，JVM 会把这个符号引用替换为`toString()`方法在方法区的实际内存地址（直接引用）。
    
      
    
      **JVM规范中各类加载器加载管辖范围** 全限定名确定
      
      - 引导类加载器BootStrapClassLoader(jre/Lib下面的jar包中的类)，该加载器由C/C++编写。涉及到虚拟机本地实现细节，因此无法获取该引用，如果用getClassLoader()来获取是会返回null的
      
      - 扩展类加载器ExtClassLoader(jre/Lib/ext下面的一些jar包中的类)，该加载器由Java编写
      
      - 应用类加载器AppClassLoader(classpath中的类, 就是你自己写的java代码转换为.class字节码的那些类)。该加载器由Java编写
      
        AppClassLoader是JDK默认提供的类加载器
      
      **双亲委派**
      
      这仨加载器是有一定的关系的。这三者区别在于负责管理加载的目录不一样。
      
      每个加载器只负责加载对应层次的代码。
      
      ![image-20251219191420195](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251219191420195.png)
      
      这几个类加载器的loadClass方法逻辑是，如果该类已被加载，则返回已加载的类对象。若未被加载，则先请求parent尝试加载，若递归这个过程根加载器也无法加载，则交回加载权
      
      比如，
      
      AppClassLoader先把对应的类名向上请求，如果是上层的交由上层，如果到顶层这个类都不属于他们该加载的，就让该层加载。如果该类属于他们的，则由他们来加载，如果已经加载过了返回一个Class对象给下层。
      
      
      
      好处：
      
      ①避免重复加载类，由于各个层级的加载器不知道其他层级的加载器是否加载过某个类，这样递归请求可以避免重复加载相同的类
      
      ②防止核心API被篡改，如Java.lang.String。黑客只通过在classpath里面写个同样的类名就不能串改核心库里的String了。因为AppClassLoader先向上请求，去找jre/Lib下的java.lang.String。
      
      **如何打破双亲委派**：自定义类加载器，重写loadClass方法，使其不进行双亲委派即可
      
      **例子**
      
      1. Tomcat中页编写了个自定义类加载器WebAppClassLoader，重写了loadClass打破双亲委派。
      
      2. JDBC driver
      
      **为什么Tomcat要打破双亲委派**
      
      **Web容器**是为网络应用提供运行时环境的服务程序，主要负责处理客户端请求，支持生成动态HTML页面和数据库通信等功能。典型代表包括Java技术栈的Tomcat、Jetty容器，以及ASP技术栈的IIS、[PWS](https://baike.baidu.com/item/PWS/273000?fromModule=lemma_inlink)容器。

- 并发编程

  掌握核心工具，而非深入所有细节

  核心机制与工具：必须掌握 synchronized、volatile 的关键字作用，理解 CAS 乐观锁思想，并熟练使用 ReentrantLock、ThreadLocal 及 线程池 这些核心并发工具。

  学习建议：多思考“为什么”，例如为什么要用线程池？synchronized 和 ReentrantLock 有什么区别？理解其设计初衷比死记硬背更重要。

  

![img](https://uploadfiles.nowcoder.com/images/20251130/664521299_1764493141928/D2B5CA33BD970F64A6301FA75AE2EB22)

- 